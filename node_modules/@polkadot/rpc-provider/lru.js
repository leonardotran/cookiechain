export const DEFAULT_CAPACITY = 64;
class LRUNode {
    key;
    __internal__lastAccess;
    createdAt;
    next;
    prev;
    constructor(key) {
        this.key = key;
        this.__internal__lastAccess = Date.now();
        this.createdAt = this.__internal__lastAccess;
        this.next = this.prev = this;
    }
    refresh() {
        this.__internal__lastAccess = Date.now();
    }
    get lastAccess() {
        return this.__internal__lastAccess;
    }
}
export class LRUCache {
    capacity;
    __internal__data = new Map();
    __internal__refs = new Map();
    __internal__length = 0;
    __internal__head;
    __internal__tail;
    __internal__ttl;
    __internal__ttlInterval;
    __internal__ttlTimerId = null;
    constructor(capacity = DEFAULT_CAPACITY, ttl = 30000, ttlInterval = 15000) {
        this.capacity = capacity;
        this.__internal__ttl = ttl;
        this.__internal__ttlInterval = ttlInterval;
        this.__internal__head = this.__internal__tail = new LRUNode('<empty>');
        // make sure the interval is not longer than the ttl
        if (this.__internal__ttlInterval > this.__internal__ttl) {
            this.__internal__ttlInterval = this.__internal__ttl;
        }
    }
    get ttl() {
        return this.__internal__ttl;
    }
    get ttlInterval() {
        return this.__internal__ttlInterval;
    }
    get length() {
        return this.__internal__length;
    }
    get lengthData() {
        return this.__internal__data.size;
    }
    get lengthRefs() {
        return this.__internal__refs.size;
    }
    entries() {
        const keys = this.keys();
        const count = keys.length;
        const entries = new Array(count);
        for (let i = 0; i < count; i++) {
            const key = keys[i];
            entries[i] = [key, this.__internal__data.get(key)];
        }
        return entries;
    }
    keys() {
        const keys = [];
        if (this.__internal__length) {
            let curr = this.__internal__head;
            while (curr !== this.__internal__tail) {
                keys.push(curr.key);
                curr = curr.next;
            }
            keys.push(curr.key);
        }
        return keys;
    }
    get(key) {
        const data = this.__internal__data.get(key);
        if (data) {
            this.__internal__toHead(key);
            return data;
        }
        return null;
    }
    set(key, value) {
        if (this.__internal__data.has(key)) {
            this.__internal__toHead(key);
        }
        else {
            const node = new LRUNode(key);
            this.__internal__refs.set(node.key, node);
            if (this.length === 0) {
                this.__internal__head = this.__internal__tail = node;
            }
            else {
                this.__internal__head.prev = node;
                node.next = this.__internal__head;
                this.__internal__head = node;
            }
            if (this.__internal__length === this.capacity) {
                this.__internal__data.delete(this.__internal__tail.key);
                this.__internal__refs.delete(this.__internal__tail.key);
                this.__internal__tail = this.__internal__tail.prev;
                this.__internal__tail.next = this.__internal__head;
            }
            else {
                this.__internal__length += 1;
            }
        }
        if (this.__internal__ttl > 0 && !this.__internal__ttlTimerId) {
            this.__internal__ttlTimerId = setInterval(() => {
                this.__internal__ttlClean();
            }, this.__internal__ttlInterval);
        }
        this.__internal__data.set(key, value);
    }
    __internal__ttlClean() {
        // Find last node to keep
        const expires = Date.now() - this.__internal__ttl;
        // traverse map to find the lastAccessed
        while (this.__internal__tail.lastAccess && this.__internal__tail.lastAccess < expires && this.__internal__length > 0) {
            if (this.__internal__ttlTimerId && this.__internal__length === 0) {
                clearInterval(this.__internal__ttlTimerId);
                this.__internal__ttlTimerId = null;
                this.__internal__head = this.__internal__tail = new LRUNode('<empty>');
            }
            else {
                this.__internal__refs.delete(this.__internal__tail.key);
                this.__internal__data.delete(this.__internal__tail.key);
                this.__internal__length -= 1;
                this.__internal__tail = this.__internal__tail.prev;
                this.__internal__tail.next = this.__internal__head;
            }
        }
    }
    __internal__toHead(key) {
        const ref = this.__internal__refs.get(key);
        if (ref && ref !== this.__internal__head) {
            ref.refresh();
            ref.prev.next = ref.next;
            ref.next.prev = ref.prev;
            ref.next = this.__internal__head;
            this.__internal__head.prev = ref;
            this.__internal__head = ref;
        }
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async clearInterval() {
        if (this.__internal__ttlTimerId) {
            clearInterval(this.__internal__ttlTimerId);
            this.__internal__ttlTimerId = null;
        }
    }
}
